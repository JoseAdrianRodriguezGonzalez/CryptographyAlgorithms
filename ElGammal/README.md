
# ElGamal

The ElGamal algorithm is a public-key cryptosystem based on the hardness of the
Discrete Logarithm Problem over finite cyclic groups.

---

## Definition

Let $F$ be a finite field. Then the multiplicative group $F^\times$ has
$N$ elements, where $N = pM$, with $p$ a large prime number.

Since $F^\times$ is cyclic, there exists an element $f \in F^\times$
of order $pM$. Define
$$g = f^M$$

Then $g$ has order $p$, and the subgroup generated by $g$ is

$$
G = \langle g \rangle = \{ g^0 = 1, g^1, g^2, \dots, g^{p-1} \}
$$

---

## Key Generation

Choose a secret integer $c$ such that

$$
1 \le c \le p-2
$$

and compute
$$h = g^c$$

- Public key: $(g, h)$
- Private key: $c$

---

## Encryption

Let $x \in G$ be the plaintext message.

Choose a random integer $k$ such that

$$
1 \le k \le p-2
$$

The encryption function is defined as:

$$
\text{Enc}_c(x) = (g^k, x h^k)
$$

---

## Decryption

Given a ciphertext $(x_1, x_2) \in G \times G$, the decryption function is:

$$
\text{Dec}_c(x_1, x_2) = x_2 \cdot x_1^{-c}
$$

---

## Proof of Correctness

We show that decryption recovers the original message:

$$
\text{Dec}_c(\text{Enc}_c(x)) = x
$$

Let

$$
\text{Enc}_c(x) = (g^k, x h^k)
$$

Then

$$
\begin{aligned}
\text{Dec}_c(g^k, x h^k)
&= x h^k \cdot (g^k)^{-c} \\
&= x g^{ck} \cdot g^{-ck} \\
&= x
\end{aligned}
$$

This proves the correctness of the ElGamal decryption algorithm.

## Pseudo code 

```Pseudo
function FieldGenerator(bitLength)
    repeat 
      p ← generateRandomPrime(bitLength)
      M ← randint(bitLength)
      q ← pM+1 
    until q is prime
  return p,M,q 
```

The field has been defined, as it $F=\mathbf{F}_q$.
So $|F^\times|=q-1=pM$
By definition, if we have $g=f^M$, we can choose randomly element of $f$ within the field, but there's some defintion that must be accomplished
$$ord(f^M)=\frac{ord(f)}{gcd(ord(f),M)}$$
This is because a lemma, and it means that $ord(f)|pM$
So the possible values that can have is $1,p,M,pM$

```Pseudo
function keyGenerator(bitlength)
  p,M,q  ← FieldGenerator(bitLength)
  repeat 
    f ← randomValue within the field within q-1 
    g  ← f^M mod q 
  until $g \neq 1$
  h ← $g^c \pmod{q}$
  c ← randomValue $0 < c < p$
  return p,M,q,c,g 
``` 
```
```

The reason that $g\equiv f^M mod q$, is because. Let $f^M=kq+g$, if $g$ has order $p$. it means that $ord(p)$ divides M, or $g=F^M$. and $ord(g)=p$, and to prove this, we can see, that we have our generator letting it as $g^p=1$
$$f^{Mp}=f^{q-1}=1$$, by Fermat 
$$f^{q-1}\equiv 1 mod q $$
So this can be seen as 
$$g^p \equiv 1 \pmod{q}$$

Finally, if we have 
$$ord(g)=p$$
There's a definiton that is says that let a $G$ finite group and $g$ element in $G$. If $g^k=e$, so the $k|ord(g)$
As p is a prime,the unique values that can divide it are $1$ or $p$, so if $g\equiv 1 \pmod{q}$, but it implies if $ord(g)=1$. But it can not be that, so 
$$ord(g)=p$$
For that reason, the value cannot be 1, and $f^M \mod q$, due to the cyclic group, is closed, the value g has to be another prime value

```Pseudo

function Encrypt(g, h, q, x):
    k ← random integer in {1,…,p−2}
    x1 ← pow(g, k, q)
    x2 ← (x * pow(h, k, q)) mod q
    return (x1, x2)

function Decrypt(c, q, x1, x2):
    s ← pow(x1, c, q)
    s_inv ← mod_inverse(s, q)
    return (x2 * s_inv) mod q
```

